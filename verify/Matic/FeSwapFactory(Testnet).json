{
  "language": "Solidity",
  "sources":
  {
    "contracts/interfaces/IFeSwapFactory.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\ninterface IFeSwapFactory {\r\n    event PairCreated(address indexed tokenA, address indexed tokenB, address pairAAB, address pairABB, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function getFeeInfo() external view returns (address, uint256);\r\n    function factoryAdmin() external view returns (address);\r\n    function routerFeSwap() external view returns (address);  \r\n    function nftFeSwap() external view returns (address);  \r\n    function rateTriggerFactory() external view returns (uint16);  \r\n    function rateCapArbitrage() external view returns (uint16);     \r\n    function rateProfitShare() external view returns (uint16); \r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pairAB, address pairBA);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createUpdatePair(address tokenA, address tokenB, address pairOwner, uint256 rateTrigger, uint256 switchOracle) \r\n                                external returns (address pairAAB,address pairABB);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFactoryAdmin(address) external;\r\n    function setRouterFeSwap(address) external;\r\n    function configFactory(uint16, uint16, uint16) external;\r\n//  function managePair(address, address, address, address, uint256) external;\r\n    function getPairTokens() external view returns (address pairIn, address pairOut);\r\n}"
    },
    "contracts/interfaces/IFeSwapERC20.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\ninterface IFeSwapERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"
    },
    "contracts/interfaces/IFeSwapPair.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\nimport \"./IFeSwapERC20.sol\";\r\n\r\ninterface IFeSwapPair is IFeSwapERC20 {\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(address indexed sender, uint amount0In, uint amount1In, uint amount1Out, address indexed to );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function pairOwner() external view returns (address);\r\n    function tokenIn() external view returns (address);\r\n    function tokenOut() external view returns (address);\r\n    function getReserves() external view returns ( uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast);\r\n    function getReservesWithRate() external view returns ( uint112 _reserveIn, uint112 _reserveOut, uint _rateArbitrage);\r\n    function getOracleInfo() external view returns (uint, uint, uint);\r\n    \r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amountOut, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address, uint, uint) external;\r\n}"
    },
    "contracts/libraries/SafeMath.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) \u003e= x, \u0027ds-math-add-overflow\u0027);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003c= x, \u0027ds-math-sub-underflow\u0027);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \u0027ds-math-mul-overflow\u0027);\r\n    }\r\n}"
    },
    "contracts/FeSwapERC20.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\nimport \"./interfaces/IFeSwapERC20.sol\";\r\nimport \"./libraries/SafeMath.sol\";\r\n\r\ncontract FeSwapERC20 is IFeSwapERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant override name = \u0027FeSwap\u0027;\r\n    string public constant override symbol = \u0027FESP\u0027;\r\n    uint8 public constant override decimals = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address =\u003e uint) public override balanceOf;\r\n    mapping(address =\u003e mapping(address =\u003e uint)) public override allowance;\r\n\r\n    bytes32 public immutable override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address =\u003e uint) public override nonces;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() public {\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\u0027EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\u0027),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\u00271\u0027)),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint).max) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) override external {\r\n        require(deadline \u003e= block.timestamp, \u0027FeSwap: EXPIRED\u0027);\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \u0027\\x19\\x01\u0027,\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \u0027FeSwap: INVALID_SIGNATURE\u0027);\r\n        _approve(owner, spender, value);\r\n    }\r\n}"
    },
    "contracts/libraries/Math.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x \u003c y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y \u003e 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x \u003c z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}"
    },
    "contracts/libraries/UQ112x112.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}"
    },
    "contracts/interfaces/IERC20.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}"
    },
    "contracts/interfaces/IFeSwapCallee.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\ninterface IFeSwapCallee {\r\n    function FeSwapCall(address sender, uint amountOut, bytes calldata data) external;\r\n}"
    },
    "contracts/libraries/TransferHelper.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes(\u0027approve(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: APPROVE_FAILED\u0027);\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes(\u0027transfer(address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FAILED\u0027);\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes(\u0027transferFrom(address,address,uint256)\u0027)));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \u0027TransferHelper: TRANSFER_FROM_FAILED\u0027);\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, \u0027TransferHelper: ETH_TRANSFER_FAILED\u0027);\r\n    }\r\n}"
    },
    "contracts/FeSwapPair.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\nimport \"./interfaces/IFeSwapPair.sol\";\r\nimport \"./FeSwapERC20.sol\";\r\nimport \"./libraries/Math.sol\";\r\nimport \"./libraries/UQ112x112.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IFeSwapFactory.sol\";\r\nimport \"./interfaces/IFeSwapCallee.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\n\r\ncontract FeSwapPair is IFeSwapPair, FeSwapERC20 {\r\n\r\n    using SafeMath  for uint;\r\n    using UQ112x112 for uint224;\r\n\r\n    uint public constant override MINIMUM_LIQUIDITY = 10**3;\r\n\r\n    address public immutable override factory;\r\n    address public immutable override tokenIn;\r\n    address public immutable override tokenOut;\r\n    address public override pairOwner;\r\n\r\n    uint112 private reserveIn;              // uses single storage slot, accessible via getReserves\r\n    uint112 private reserveOut;             // uses single storage slot, accessible via getReserves\r\n    uint32  private blockTimestampLast;     // uses single storage slot, accessible via getReserves\r\n\r\n    uint private price0CumulativeLast;\r\n    uint private price1CumulativeLast;\r\n    uint private kLast;                     // reserveIn * reserveOut, as of immediately after the most recent liquidity event\r\n\r\n    uint private rateTriggerArbitrage;\r\n\r\n    uint private unlocked = 0x5A;\r\n    modifier lock() {\r\n        require(unlocked == 0x5A, \u0027FeSwap: LOCKED\u0027);\r\n        unlocked = 0x69;\r\n        _;\r\n        unlocked = 0x5A;\r\n    }\r\n  \r\n    function getReserves() public view override returns ( uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast) {\r\n        _reserveIn = reserveIn;\r\n        _reserveOut = reserveOut;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function getReservesWithRate() external view override returns ( uint112 _reserveIn, uint112 _reserveOut, uint _rateArbitrage) {\r\n        _reserveIn = reserveIn;\r\n        _reserveOut = reserveOut;\r\n        _rateArbitrage = rateTriggerArbitrage;\r\n     }\r\n\r\n    function getOracleInfo() public view override returns ( uint _price0CumulativeLast, uint _price1CumulativeLast, uint _kLast) {\r\n        return (price0CumulativeLast, price1CumulativeLast, kLast);\r\n    }\r\n\r\n    event Mint(address indexed sender, uint amountIn, uint amountOut);\r\n    event Burn(address indexed sender, uint amountIn, uint amountOut, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserveIn, uint112 reserveOut);\r\n\r\n    constructor() public {\r\n        factory     = msg.sender;\r\n        (tokenIn, tokenOut) = IFeSwapFactory(msg.sender).getPairTokens();\r\n    }\r\n\r\n    function initialize(address _pairOwner, address router, uint rateTrigger, uint switchOracle) external override {\r\n        require(msg.sender == factory, \u0027FeSwap: FORBIDDEN\u0027);\r\n        \r\n        address _tokenIn = tokenIn;\r\n        if(pairOwner == address(type(uint160).max)) {\r\n            TransferHelper.safeApprove(_tokenIn, router, 0);                    // Remove Approve, only from Factory admin\r\n        } else {\r\n            pairOwner  = _pairOwner;\r\n            if(router != address(0))\r\n                TransferHelper.safeApprove(_tokenIn, router, type(uint).max);   // Approve Rourter to transfer out tokenIn for auto-arbitrage\r\n        }\r\n\r\n        if(rateTrigger != 0)  rateTriggerArbitrage = uint16(rateTrigger); \r\n\r\n        if(switchOracle == 0)  return;                                          // = 0, do not change the oracle setting\r\n        if(switchOracle == uint(1)) {                                           // = 1, open price oracle setting  \r\n            blockTimestampLast = uint32(block.timestamp % 2**32);\r\n            return;\r\n        }\r\n        if(switchOracle == type(uint).max) {                                    // = -1, close price oracle setting  \r\n            blockTimestampLast = 0;\r\n            price0CumulativeLast = 0;\r\n            price1CumulativeLast = 0;\r\n        }\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balanceIn, uint balanceOut, uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast) private {\r\n        require(balanceIn \u003c= type(uint112).max \u0026\u0026 balanceOut \u003c= type(uint112).max, \u0027FeSwap: OVERFLOW\u0027);\r\n        uint32 blockTimestamp = 0;\r\n        if(_blockTimestampLast != 0){           // check if oracle is activated or not\r\n            blockTimestamp = uint32(block.timestamp % 2**32);\r\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\r\n            if (timeElapsed \u003e 0 \u0026\u0026 _reserveIn != 0 \u0026\u0026 _reserveOut != 0) {\r\n                // * never overflows, and + overflow is desired\r\n                price0CumulativeLast += uint(UQ112x112.encode(_reserveOut).uqdiv(_reserveIn)) * timeElapsed;\r\n                price1CumulativeLast += uint(UQ112x112.encode(_reserveIn).uqdiv(_reserveOut)) * timeElapsed;\r\n            }\r\n        }\r\n        reserveIn = uint112(balanceIn);\r\n        reserveOut = uint112(balanceOut);\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserveIn, reserveOut);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n    function _mintFee(uint112 _reserveIn, uint112 _reserveOut) private returns (bool feeOn) {\r\n        (address feeTo, uint rateProfitShare) = IFeSwapFactory(factory).getFeeInfo();\r\n        feeOn = (feeTo != address(0)) || (pairOwner != address(0));\r\n        uint _kLast = kLast;            // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = uint(_reserveIn).mul(_reserveOut);\r\n                if (rootK \u003e _kLast.add(uint(_reserveIn).mul(200))) {     // ignore swap dust increase, select 200 randomly \r\n                    rootK = Math.sqrt(rootK);\r\n                    _kLast = Math.sqrt(_kLast);\r\n                    uint numerator = totalSupply.mul(rootK.sub(_kLast)).mul(6);\r\n                    uint denominator = rootK.mul(rateProfitShare).add(_kLast);\r\n                    uint liquidityOwner = numerator / (denominator.mul(10));\r\n                    if((liquidityOwner \u003e 0) \u0026\u0026 (pairOwner != address(0))) {\r\n                        _mint(pairOwner, liquidityOwner);\r\n                    } \r\n                    uint liquidityFeSwap = numerator / (denominator.mul(15));\r\n                    if((liquidityFeSwap \u003e 0)  \u0026\u0026 (feeTo != address(0))) {\r\n                        _mint(feeTo, liquidityFeSwap);\r\n                    } \r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }            \r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external override lock returns (uint liquidity) {\r\n        (uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast) = getReserves(); // gas savings\r\n        uint balanceIn = IERC20(tokenIn).balanceOf(address(this));\r\n        uint balanceOut = IERC20(tokenOut).balanceOf(address(this));\r\n        uint amountTokenIn = balanceIn.sub(_reserveIn);\r\n        uint amountTokenOut = balanceOut.sub(_reserveOut);\r\n\r\n        bool feeOn = _mintFee(_reserveIn, _reserveOut);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amountTokenIn.mul(amountTokenOut)).sub(MINIMUM_LIQUIDITY);\r\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amountTokenIn.mul(_totalSupply) / _reserveIn, amountTokenOut.mul(_totalSupply) / _reserveOut);\r\n        }\r\n        require(liquidity \u003e 0, \u0027FeSwap: INSUFFICIENT_LIQUIDITY_MINTED\u0027);\r\n        _mint(to, liquidity);\r\n\r\n        _update(balanceIn, balanceOut, _reserveIn, _reserveOut, _blockTimestampLast);\r\n        if (feeOn) kLast = uint(reserveIn).mul(reserveOut);                    // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amountTokenIn, amountTokenOut);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external lock override returns (uint amountIn, uint amountOut) {\r\n        (uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast) = getReserves();     // gas savings\r\n        (address _tokenIn, address _tokenOut) = (tokenIn, tokenOut);    // gas savings\r\n        uint balanceIn = IERC20(_tokenIn).balanceOf(address(this));\r\n        uint balanceOut = IERC20(_tokenOut).balanceOf(address(this));\r\n        uint liquidity = balanceOf[address(this)];                      // liquidity to remove\r\n\r\n        bool feeOn = _mintFee(_reserveIn, _reserveOut);\r\n        uint _totalSupply = totalSupply;                        // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amountIn = liquidity.mul(balanceIn) / _totalSupply;     // using balances ensures pro-rata distribution\r\n        amountOut = liquidity.mul(balanceOut) / _totalSupply;   // using balances ensures pro-rata distribution\r\n        require(amountIn \u003e 0 \u0026\u0026 amountOut \u003e 0, \u0027FeSwap: INSUFFICIENT_LIQUIDITY_BURNED\u0027);\r\n\r\n        _burn(address(this), liquidity);\r\n        TransferHelper.safeTransfer(_tokenIn, to, amountIn);\r\n        TransferHelper.safeTransfer(_tokenOut, to, amountOut);\r\n        balanceIn = IERC20(_tokenIn).balanceOf(address(this));      // can use?: balanceIn = balanceIn.sub(amountIn)\r\n        balanceOut = IERC20(_tokenOut).balanceOf(address(this));\r\n\r\n        _update(balanceIn, balanceOut, _reserveIn, _reserveOut, _blockTimestampLast);\r\n        if (feeOn) kLast = uint(reserveIn).mul(reserveOut);     // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amountIn, amountOut, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amountOut, address to, bytes calldata data) external lock override {\r\n        require(amountOut \u003e 0, \u0027FeSwap: INSUFFICIENT_OUTPUT_AMOUNT\u0027);\r\n        (uint112 _reserveIn, uint112 _reserveOut, uint32 _blockTimestampLast) = (reserveIn, reserveOut, blockTimestampLast);   // gas savings\r\n        require(amountOut \u003c _reserveOut, \u0027FeSwap: INSUFFICIENT_LIQUIDITY\u0027);\r\n\r\n        uint balanceIn;\r\n        uint balanceOut;\r\n        {   // scope for {_tokenIn, _tokenOut}, avoids stack too deep errors\r\n            (address _tokenIn, address _tokenOut) = (tokenIn, tokenOut);            // gas savings\r\n            require(to != _tokenIn \u0026\u0026 to != _tokenOut, \u0027FeSwap: INVALID_TO\u0027);\r\n            TransferHelper.safeTransfer(_tokenOut, to, amountOut); \r\n            if (data.length \u003e 0) IFeSwapCallee(to).FeSwapCall(msg.sender, amountOut, data);\r\n            balanceIn = IERC20(_tokenIn).balanceOf(address(this));\r\n            balanceOut = IERC20(_tokenOut).balanceOf(address(this));\r\n        }\r\n\r\n        uint amountInTokenIn = balanceIn \u003e _reserveIn ? balanceIn - _reserveIn : 0;\r\n        uint amountInTokenOut = balanceOut \u003e (_reserveOut - amountOut) \r\n                                           ? balanceOut - (_reserveOut - amountOut) : 0;  // to support Flash Swap\r\n        require(amountInTokenIn \u003e 0 || amountInTokenOut \u003e 0, \u0027FeSwap: INSUFFICIENT_INPUT_AMOUNT\u0027);\r\n\r\n        {   // avoid stack too deep errors\r\n            uint balanceOutAdjusted = balanceOut.mul(1000);\r\n            if(amountInTokenOut\u003e0) balanceOutAdjusted = balanceOutAdjusted.sub(amountInTokenOut.mul(3)); // Fee for Flash Swap: 0.3% from tokenOut\r\n            require(balanceIn.mul(balanceOutAdjusted) \u003e= uint(_reserveIn).mul(_reserveOut).mul(1000), \u0027FeSwap: K\u0027);\r\n        }\r\n        _update(balanceIn, balanceOut, _reserveIn, _reserveOut, _blockTimestampLast);\r\n        emit Swap(msg.sender, amountInTokenIn, amountInTokenOut, amountOut, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external lock override {\r\n        (address _tokenIn, address _tokenOut) = (tokenIn, tokenOut);         // gas savings\r\n        TransferHelper.safeTransfer(_tokenIn, to, IERC20(_tokenIn).balanceOf(address(this)).sub(reserveIn));\r\n        TransferHelper.safeTransfer(_tokenOut, to, IERC20(_tokenOut).balanceOf(address(this)).sub(reserveOut));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external lock override {\r\n        _update(IERC20(tokenIn).balanceOf(address(this)), IERC20(tokenOut).balanceOf(address(this)), reserveIn, reserveOut, blockTimestampLast);\r\n    }\r\n}"
    },
    "contracts/patch/FactoryPatchCaller.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity \u003e=0.6.12;\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to the patch \r\n *      using the EVM instruction `delegatecall`. The success and return data of the delegated call \r\n *      will be returned back to the caller of the proxy.\r\n */\r\nabstract contract FactoryPatchCaller {\r\n    // DELEGATE_TARGET = uint160(                      // downcast to match the address type.\r\n    //                      uint256(                    // convert to uint to truncate upper digits.\r\n    //                          keccak256(                // compute the CREATE2 hash using 4 inputs.\r\n    //                              abi.encodePacked(       // pack all inputs to the hash together.\r\n    //                                  hex\"ff\",              // start with 0xff to distinguish from RLP.\r\n    //                                  address(this),        // this contract will be the caller.\r\n    //                                  salt,                 // pass in the supplied salt value.\r\n    //                                  _metamorphicContractInitializationCodeHash // the init code hash.\r\n    //                              )\r\n    //                          )\r\n    //                      )\r\n    //                   )\r\n    //\r\n    // salt = keccak256(\"Feswap Factory Patch\") = 0x804853013B8794AECE4A460DFA60AAD95CCF1CB9435B71BFAAB287F39536A9DD\r\n    // metamorphicContractInitializationCode = 0x60006020816004601c335a63aaf10f428752fa60185780fd5b808151803b80938091923cf3\r\n    // _metamorphicContractInitializationCodeHash = keccak256(metamorphicContractInitializationCode)\r\n    //                                            = 0x15bfb1132dc67a984de77a9eef294f7e58964d02c62a359fd6f3c0c1d443e35c \r\n    // address(this): 0xFDFEF9D10d929cB3905C71400ce6be1990EA0F34 (Test) \r\n    // address(this): 0x8565570A7cB2b2508F9180AD83e8f58F25e41596 (Goerli) \r\n    // address(this): 0x6A8FE4753AB456e85E1379432d92ABF1fB49B5Df (Rinkeby/BSC/Polygon/Harmoney/Arbitrum/Fantom/Avalance/Heco Testnet) \r\n    // address(this): 0x0528D7de63aafdF748a5ef530949C80c4e8fbeC7 (Polygon Mainnet) \r\n   \r\n//  address public constant DELEGATE_TARGET = 0x92DD76703DACF9BE7F61CBC7ADAF77319084DBF8;   // (Goerli)\r\n//  address public constant DELEGATE_TARGET = 0x8CAF582948011A604d53DBAb24783aC0f0464b3d;   // (Test)\r\n    address public constant DELEGATE_TARGET = 0x8C80f5aa060fD83faDC384Ffc469ceD5548cF554;   // (BSC/MATIC Testnet)\r\n//  address public constant DELEGATE_TARGET = 0xb9c7fc86878409E3B87EdCc221C9caf8d7c25bF2;   // (Polygon Mainnet)\r\n\r\n    /**\r\n     * @dev Delegates the current call to `DELEGATE_TARGET`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n\r\n    receive() external virtual payable {\r\n        revert(\"Refused!\");\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback () external payable virtual {\r\n       // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don\u0027t know the size yet.\r\n            let result := delegatecall(gas(), DELEGATE_TARGET, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/FeSwapFactory.sol":
    {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.6.12;\r\n\r\nimport \"./interfaces/IFeSwapFactory.sol\";\r\nimport \"./interfaces/IFeSwapERC20.sol\";\r\nimport \"./FeSwapPair.sol\";\r\nimport \"./patch/FactoryPatchCaller.sol\";\r\n\r\ncontract FeSwapFactory is IFeSwapFactory, FactoryPatchCaller {\r\n    uint16 public constant RATE_TRIGGER_FACTORY         = 10;       //  price difference be 1%\r\n    uint16 public constant RATE_CAP_TRIGGER_ARBITRAGE   = 50;       //  price difference \u003c 5%\r\n    uint16 public constant RATE_PROFIT_SHARE            = 11;       //  FeSwap and Pair owner share 1/12 of the swap profit, 11 means 1/12\r\n\r\n    address public immutable override nftFeSwap;                    \r\n\r\n    address public override factoryAdmin;                           // Storage Slot 0\r\n    address public override routerFeSwap;                           // Storage Slot 1\r\n    address public override feeTo;                                  // Storage Slot 2\r\n    uint16 public override rateProfitShare;                         // Storage Slot 2;  1/X =\u003e rateProfitShare = (X-1)\r\n    uint16 public override rateTriggerFactory;                      // Storage Slot 2    \r\n    uint16 public override rateCapArbitrage;                        // Storage Slot 2\r\n\r\n    address[] public override allPairs;                             // Storage Slot 3\r\n    mapping(address =\u003e address) public twinPairs;                   // Storage Slot 4\r\n\r\n    address private tokenInCreating;                                // Storage Slot 5\r\n    address private tokenOutCreating;                               // Storage Slot 6\r\n\r\n    event PairCreated(address indexed tokenA, address indexed tokenB, address pairAAB, address pairABB, uint allPairsLength);\r\n\r\n    constructor(address _factoryAdmin, address _routerFeSwap, address _nftFeSwap) public {       // factoryAdmin will be set to TimeLock after FeSwap works normally\r\n        factoryAdmin        = _factoryAdmin;\r\n        routerFeSwap        = _routerFeSwap;\r\n        nftFeSwap           = _nftFeSwap;\r\n        rateTriggerFactory  = RATE_TRIGGER_FACTORY;\r\n        rateCapArbitrage    = RATE_CAP_TRIGGER_ARBITRAGE;\r\n        rateProfitShare     = RATE_PROFIT_SHARE;\r\n     }\r\n\r\n    function allPairsLength() external view override returns (uint) {\r\n        return allPairs.length;\r\n    }\r\n    \r\n    function getPair(address tokenIn, address tokenOut) public view override  returns (address, address) {\r\n        bool inverseOrder = tokenIn \u003e tokenOut;\r\n        if(inverseOrder) (tokenIn, tokenOut) = (tokenOut, tokenIn);\r\n\r\n        address pairA = address(uint(keccak256(abi.encodePacked( hex\u0027ff\u0027, address(this),\r\n                keccak256(abi.encodePacked(tokenIn, tokenOut)),\r\n                hex\u00271b68a89c18551451d63580e66fda7aee3ccf09c7317f32b6747ff18b1173ad09\u0027 // init code hash // save gas\r\n            ))));\r\n\r\n        address pairB = twinPairs[pairA];\r\n        if(pairB == address(0)) return (pairB, pairB);\r\n        if(inverseOrder) return (pairB, pairA);\r\n        return (pairA, pairB);\r\n    }\r\n\r\n    function getFeeInfo() external view override returns (address _feeTo, uint256 _rateProfitShare) {\r\n        return (feeTo, rateProfitShare);\r\n    }\r\n\r\n    function createUpdatePair(address tokenA, address tokenB, address pairOwner, uint256 rateTrigger, uint256 switchOracle) \r\n                                external override returns (address pairAAB, address pairABB ) {\r\n        require(tokenA != tokenB, \u0027FeSwap: IDENTICAL_ADDRESSES\u0027);\r\n        // pairOwner allowed to zero to discard the profit\r\n        require(tokenA != address(0) \u0026\u0026 tokenB != address(0), \u0027FeSwap: ZERO_ADDRESS\u0027);\r\n        require((msg.sender == nftFeSwap) || (msg.sender == factoryAdmin), \u0027FeSwap: FORBIDDEN\u0027);\r\n        uint16 _rateTriggerFactory = rateTriggerFactory;            // to save gas fee\r\n        require(rateTrigger \u003c= rateCapArbitrage, \u0027FeSwap: GAP TOO MORE\u0027);\r\n\r\n        if(tokenA \u003e tokenB) (tokenA, tokenB) = (tokenB, tokenA);\r\n\r\n        (pairAAB, pairABB) = getPair(tokenA, tokenB);\r\n        if(pairAAB != address(0)) {\r\n            address _routerFeSwap = address(0);\r\n            if((msg.sender == factoryAdmin) \u0026\u0026 (pairOwner == address(type(uint160).max))) {\r\n                // Remove approval to disable token pair functionality\r\n                _routerFeSwap = routerFeSwap;   \r\n            }\r\n            \r\n            if(rateTrigger != 0) rateTrigger = rateTrigger*6 + _rateTriggerFactory*4 + 10000;     // base is 10000\r\n            IFeSwapPair(pairAAB).initialize(pairOwner, _routerFeSwap, rateTrigger, switchOracle);\r\n            IFeSwapPair(pairABB).initialize(pairOwner, _routerFeSwap, rateTrigger, switchOracle);\r\n        } else {\r\n            require(pairOwner != address(type(uint160).max), \u0027FeSwap: ZERO_ADDRESS\u0027);\r\n            bytes memory bytecode = type(FeSwapPair).creationCode;\r\n\r\n            tokenInCreating = tokenA;   \r\n            tokenOutCreating = tokenB;     \r\n            bytes32 saltAAB = keccak256(abi.encodePacked(tokenA, tokenB));\r\n            assembly {\r\n                pairAAB := create2(0, add(bytecode, 32), mload(bytecode), saltAAB)\r\n            }\r\n\r\n            tokenInCreating = tokenB;\r\n            tokenOutCreating = tokenA;     \r\n            bytes32 saltABB = keccak256(abi.encodePacked(tokenB, tokenA));\r\n            assembly {\r\n                pairABB := create2(0, add(bytecode, 32), mload(bytecode), saltABB)\r\n            }\r\n\r\n            if(rateTrigger == 0) rateTrigger = _rateTriggerFactory;\r\n            rateTrigger = rateTrigger*6 + _rateTriggerFactory*4 + 10000;\r\n\r\n            address _routerFeSwap = routerFeSwap;\r\n            IFeSwapPair(pairAAB).initialize(pairOwner, _routerFeSwap, rateTrigger, switchOracle);\r\n            IFeSwapPair(pairABB).initialize(pairOwner, _routerFeSwap, rateTrigger, switchOracle);\r\n            twinPairs[pairAAB] = pairABB;\r\n            allPairs.push(pairAAB);\r\n\r\n            emit PairCreated(tokenA, tokenB, pairAAB, pairABB, allPairs.length);\r\n\r\n        }\r\n    }\r\n\r\n    // Used by FeSwapPair from its constructor\r\n    function getPairTokens() external view override returns (address pairIn, address pairOut) {\r\n        return (tokenInCreating, tokenOutCreating);\r\n    }\r\n\r\n    function setFeeTo(address _feeTo) external override {\r\n        require(msg.sender == factoryAdmin, \u0027FeSwap: FORBIDDEN\u0027);\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    function setFactoryAdmin(address _factoryAdmin) external override {\r\n        require(msg.sender == factoryAdmin, \u0027FeSwap: FORBIDDEN\u0027);\r\n        factoryAdmin = _factoryAdmin;\r\n    }\r\n\r\n    function setRouterFeSwap(address _routerFeSwap) external override {\r\n        require(msg.sender == factoryAdmin, \u0027FeSwap: FORBIDDEN\u0027);\r\n        routerFeSwap = _routerFeSwap;                                         // for Router Initiation\r\n    }    \r\n\r\n    function configFactory(uint16 newTriggerRate, uint16 newRateCap, uint16 newProfitShareRate) external override {\r\n        require(msg.sender == factoryAdmin, \u0027FeSwap: FORBIDDEN\u0027);\r\n        rateTriggerFactory  = newTriggerRate;\r\n        rateCapArbitrage    = newRateCap;\r\n        rateProfitShare     = newProfitShareRate;                            // 1/X =\u003e rateProfitShare = (X-1)\r\n    } \r\n}"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode.object",
          "evm.deployedBytecode.object",
          "abi",
          "metadata"
        ],
        "": ["ast"]
      }
    },
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 999999
    }
  }
}
